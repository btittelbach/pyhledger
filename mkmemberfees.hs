{-# LANGUAGE OverloadedStrings,Arrows,BangPatterns #-}

import Database.HDBC
import Database.HDBC.Sqlite3
import Prelude
import System.Environment(getArgs)
import Hledger
import Data.Time.Clock
import Data.Time.Calendar
import Data.Maybe
import Data.List(sort,sortBy)
import Data.Ord(comparing,compare)

roundTo = flip const

--showFeeTransaction :: MonthlyFee -> Transaction

euro n = amount{acommodity="EUR", aquantity=roundTo 4 n, astyle=amountstyle{asprecision=4}}

date :: IO (Integer,Int,Int) -- :: (year,month,day)
date = getCurrentTime >>= return . toGregorian . utctDay

--fromSqlDefault :: a -> SqlValue -> a
fromSqlDefault onerrx x = if x == SqlNull then onerrx else fromSql x

-- getMonths [list of years] <starting month in first year in list> <last month in last year in list>
-- generates tupes in the form (year,month)
-- e.g. getMonths [2015] 3 5 ---> [(2015,3),(2015,4),(2015,5)]
-- e.g. getMonths [2014,2015] 3 5 ---> [(2014,3),(2014,4),...,(2014,12),(2015,1),...,(2015,5)]
getMonths :: [Integer] -> Int -> Int -> [(Integer,Int)]
getMonths [] firstmonth lastmonth = []
getMonths (fy:years) firstmonth lastmonth
	| years == [] = [ (fy,m) | m <- [firstmonth .. lastmonth]]
	| otherwise = (getMonths [fy] firstmonth 12) ++ getMonths' years lastmonth

getMonths' (fy:years) lastmonth
	| years == [] = [ (fy,m) | m <- [1 .. lastmonth]]
	| otherwise = [ (fy,m) | m <- [1..12]] ++ getMonths' years lastmonth


-------------------------------------------------------------------------------------------------------
----- Generate recurring membership fee transactions from SQLite DB tables membership and persons ----- 
-------------------------------------------------------------------------------------------------------

-- for debugging
showMembershipFeeDuration :: Integer -> Int -> [SqlValue] -> String
showMembershipFeeDuration cur_year cur_month xs = pname ++ " " ++ (show firstmonthyear) ++ "-"++(show firstmonthmonth)++" " ++ (show lastmonthyear) ++ "-"++(show lastmonthmonth) ++ ":" ++ (show months)
	where
		pname = (fromSql $ xs !! 0) :: String
		firstmonthyear = (fromSql $ xs !! 1) :: Integer
		firstmonthmonth = (fromSql $ xs !! 2) :: Int
		lastmonthyear = (fromSqlDefault cur_year (xs !! 3)) :: Integer
		lastmonthmonth = (fromSqlDefault cur_month (xs !! 4)) :: Int
		fee = (fromSql $ xs !! 5) :: Double
		years = [firstmonthyear .. lastmonthyear]
		months = map show $ getMonths years firstmonthmonth lastmonthmonth

-- for debugging
showMembershipFeeMonths :: Integer -> Int -> [SqlValue] -> [String]
showMembershipFeeMonths cur_year cur_month xs = [ pname ++ (show fee) ++ (show month) | month <- months ]
	where
		pname = (fromSql $ xs !! 0) :: String
		firstmonthyear = (fromSql $ xs !! 1) :: Integer
		firstmonthmonth = (fromSql $ xs !! 2) :: Int
		lastmonthyear = (fromSqlDefault cur_year (xs !! 3)) :: Integer
		lastmonthmonth = (fromSqlDefault cur_month (xs !! 4)) :: Int
		fee = (fromSql $ xs !! 5) :: Double
		years = [firstmonthyear .. lastmonthyear]
		months = getMonths years firstmonthmonth lastmonthmonth

-- compare year/month value from sql with current date
-- return year/month from sql if before current month or
-- return current month if sql value is empty or year/month is in the future
thisMonthOrOlderFromSql :: 	Integer -> Int -> SqlValue -> SqlValue -> (Integer,Int)
thisMonthOrOlderFromSql cur_year cur_month sql_year sql_month =
	(
		if lastmonthyear < cur_year then lastmonthyear else cur_year,
		if lastmonthyear < cur_year || (lastmonthmonth < cur_month && lastmonthyear == cur_year) then lastmonthmonth else cur_month
	)
	where
		lastmonthyear = (fromSqlDefault cur_year sql_year) :: Integer
		lastmonthmonth = (fromSqlDefault cur_month sql_month) :: Int


-- generate a membership fee transation from Sql Result Row
-- mkMonthlyMembershipFeeTransactions <current year> <current month> <result-row of sql query> --> [list of one Transaction]
mkMonthlyMembershipFeeTransactions :: Integer -> Int -> [SqlValue] -> [Transaction]
mkMonthlyMembershipFeeTransactions cur_year cur_month xs = [ Transaction {
	tdate=fromGregorian (fst month) (snd month) 1,
	tdate2=Nothing,
	tstatus=False,
	tcode="",
	tdescription="Membership Fee due for "++pname,
	tcomment=(show month),
	ttags=[],
	tpostings=[
	  posting {paccount="revenue:membership-fees", pamount=Mixed [euro (-1*fee)]}
	  ,posting {paccount="assets:current:membership A/R:"++pname, pamount=missingmixedamt}
	],
	tpreceding_comment_lines="Autogenerated from sqlite database"
	} | month <- months ]
		where
			pname = (fromSql $ xs !! 0) :: String
			firstmonthyear = (fromSql $ xs !! 1) :: Integer
			firstmonthmonth = (fromSql $ xs !! 2) :: Int
			(lastmonthyear, lastmonthmonth) = thisMonthOrOlderFromSql cur_year cur_month (xs !! 3) (xs !! 4)
			fee = (fromSql $ xs !! 5) :: Double
			years = [firstmonthyear .. lastmonthyear]
			months = getMonths years firstmonthmonth lastmonthmonth

--------------------------------------------------------------------------------------------------------------------
----- Generate recurring transactions from SQLite DB tables hledger_recurringtransactions and hledger_postings ----- 
--------------------------------------------------------------------------------------------------------------------

-- generate a recurring transation from a SQL Result Row
-- mkMonthlyRecurringInternalTransfers <current year> <current month> (<result-row of sql query>, <corresponding result added by getPostingsForRecurringTransfers>) --> [list of one Transaction]
mkMonthlyRecurringInternalTransfers ::  Integer -> Int -> ([SqlValue],[[SqlValue]]) -> [Transaction]
mkMonthlyRecurringInternalTransfers cur_year cur_month (results, sqlpostings) = [ Transaction {
	tdate=fromGregorian (fst month) (snd month) 1,
	tdate2=Nothing,
	tstatus=False,
	tcode="",
	tdescription=(fromSql $ results !! 0) :: String,
	tcomment=(show month),
	ttags=[],
	tpostings=[posting {paccount=(fromSql acct),pamount=Mixed[euro (fromSql amnt)]} | acct:amnt:curr:xl <- sqlpostings],
	tpreceding_comment_lines="Autogenerated from sqlite database"
	} | month <- months ]
		where
			firstmonthyear = (fromSql $ results !! 1) :: Integer
			firstmonthmonth = (fromSql $ results !! 2) :: Int
			(lastmonthyear,lastmonthmonth) = thisMonthOrOlderFromSql cur_year cur_month (results !! 3) (results !! 4)
			years = [firstmonthyear .. lastmonthyear]
			months = getMonths years firstmonthmonth lastmonthmonth

-- checks the output of getPostingsForRecurringTransfers for validity
-- i.e. the sum of the amounts for each posting within one transaction equal zero
-- e.g. deducting 10 euro from account A we need to put 5 euro into account B and C each
filterValidPostingsList :: ([SqlValue],[[SqlValue]]) -> Bool
filterValidPostingsList (results, sqlpostings) = psum == 0.0
	where
		psum = foldl1 (+) $ map (\xxs -> (fromSql $ xxs !! 1)::Double) $ sqlpostings

-- Monad Function getPostingsForRecurringTransfers <db-connection> <sql-result> = IO (<sql-result-row>,<sql-result: corresponding postings>)
-- querys SQL from the rows in hledger_postings matching hrt_id of each hledger_recurringtransactions row
getPostingsForRecurringTransfers :: IConnection conn => conn -> [SqlValue] -> IO ([SqlValue],[[SqlValue]])
getPostingsForRecurringTransfers conn results = 
	let 
		postingsid = (results !! 5)
	in do
		sqlpostings <- quickQuery' conn "select hp_account, hp_amount, hp_currency from hledger_postings where hp_id=?" [postingsid]
		return (results,sqlpostings)

-----------------------------------------------------------------------------
----- Main: get SQLite DB as argument and output hledger data on StdOut ----- 
-----------------------------------------------------------------------------

main = do
	args <- getArgs
	conn <- connectSqlite3 (args !! 0)
	(year,month,day) <- date
	membershipfees <- quickQuery' conn "select p_name, strftime('%Y', m_firstmonth), strftime('%m',m_firstmonth), strftime('%Y',m_lastmonth), strftime('%m',m_lastmonth), m_fee from membership join persons using (p_id) order by p_name" []
	otherrecurringtransfers <- quickQuery' conn "select hrt_description, strftime('%Y', hrt_firstmonth), strftime('%m',hrt_firstmonth), strftime('%Y',hrt_lastmonth), strftime('%m',hrt_lastmonth),hp_id from hledger_recurringtransactions" []
	otherrecurringtransfers_plus_postings <- mapM (getPostingsForRecurringTransfers conn) otherrecurringtransfers
	--putStrLn $ show $ ((map (map (\x -> if x == SqlNull then "" else fromSql x)) membershipfees)::[[String]])
	--putStrLn $ show $ ((foldl (++) [] (map (showMembershipFeeMonths year month) membershipfees))::[String])
	mapM putStrLn $ map showTransaction $ sortBy (comparing tdate) $ ((foldl (++) [] (map (mkMonthlyMembershipFeeTransactions year month) membershipfees))::[Transaction]) ++ ((foldl (++) [] (map (mkMonthlyRecurringInternalTransfers year month) (filter filterValidPostingsList otherrecurringtransfers_plus_postings)))::[Transaction])
	disconnect conn

